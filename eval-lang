#!/usr/bin/python
import argparse
import os
from colour import foreground, C_NORMAL, GREY, CYAN, WHITE, MAGENTA
import random

from eval import load_clustering_json, load_ranking_json, load_ground_truths
from eval import calc_map

GROUND_TRUTH_DIR = 'corpus/pan16-author-clustering-training-dataset-2016-02-17/truth/'
GROUND_TRUTH_DIR = os.path.join(os.path.dirname(__file__), GROUND_TRUTH_DIR)


def shuffle_clustering(docs, clusters):
    keys = list(docs)
    values = list(docs)
    random.shuffle(values)
    docmap = dict(zip(keys, values))
    new_clusters = []
    for cluster in clusters:
        c = frozenset(docmap[x] for x in cluster)
        new_clusters.append(c)
    return new_clusters


def shuffle_ranking(links):
    scores, pairs = zip(*links)
    pairs = list(pairs)
    random.shuffle(pairs)
    return zip(scores, pairs)


def calc_fbcubed(clusters, truth, quiet=False):
    truth_map = {}
    for t in truth:
        for d in t:
            truth_map[d] = t

    r = 0.0
    p = 0.0
    n = 0.0

    colours = [foreground(x) for x in
               [196, 202, 208, 214, 220, 226, 190, 118, 46]]

    def colourise(x):
        return colours[int(x * (len(colours) - 1))]
    i = 0
    for cluster in clusters:
        n += len(cluster)
        for d in cluster:
            tcluster = truth_map[d]
            correct = len(cluster & tcluster)
            pp = float(correct) / len(cluster)
            rr = float(correct) / len(tcluster)
            p += pp
            r += rr
            if not quiet:
                pc = colourise(pp)
                rc = colourise(rr)
                if correct > 1:
                    label_colour = MAGENTA
                else:
                    label_colour = WHITE

                print "%sp%s%2d/%-2d%s" % (label_colour, pc, correct,
                                           len(cluster), C_NORMAL),
                print "%sr%s%2d/%-2d%s|%s" % (label_colour, rc, correct,
                                              len(tcluster), GREY, C_NORMAL),
                i += 1
                if (i % 5) == 0:
                    print
    if (i % 5) != 0 and not quiet:
        print
    print "recall    %s%s%s" % (colourise(r / n), r / n, C_NORMAL)
    print "precision %s%s%s" % (colourise(p / n), p / n, C_NORMAL)
    rp = n / p
    rr = n / r
    return 2.0 / (rp + rr)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-i', '--input-dir',
                        help='find problems here')
    parser.add_argument('-g', '--ground-truth-dir',
                        default=GROUND_TRUTH_DIR,
                        help="use this alternative control corpus")
    parser.add_argument('--shuffle', action='store_true',
                        help="randomly shuffle results (for baseline)")
    parser.add_argument('-q', '--quiet', action='store_true',
                        help="be relatively quiet")

    args = parser.parse_args()

    truths = load_ground_truths(args.ground_truth_dir)

    fbcubed_total = 0.0
    map_total = 0.0
    n = 0.0
    files = []
    for d, dirnames, filenames in os.walk(args.input_dir):
        for fn in filenames:
            files.append((d, fn))

    files.sort()
    for d, fn in files:
        pid = os.path.basename(d)
        t = truths.get(pid)
        if t is None:
            continue
        ffn = os.path.join(d, fn)
        if fn == 'ranking.json':
            ranking = load_ranking_json(ffn)
            if args.shuffle:
                ranking = shuffle_ranking(ranking)

            score = calc_map(ranking, t['ranking'], t['documents'])
            print "%s MAP %s" % (pid, score)
            n += 1.0
            map_total += score

        elif fn == 'clustering.json':
            docs, clustering = load_clustering_json(ffn)
            if args.shuffle:
                clustering = shuffle_clustering(docs, clustering)
            assert(docs == t['documents'])
            score = calc_fbcubed(clustering, t['clustering'],
                                 quiet=args.quiet)
            print "%s F(BCubed) %s" % (pid, score)
            fbcubed_total += score

    print "FBCubed mean %s" % (fbcubed_total / n)
    print "MAP mean     %s" % (map_total / n)


main()
