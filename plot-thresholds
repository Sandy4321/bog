#!/usr/bin/python
import cPickle
import numpy as np
import matplotlib.pyplot as plt
import os
import sys
import argparse
import json
import time

from operator import neg

from munge import best_connections, p_to_affinities, data_to_clusters
from munge import clipped_neg_exp, clipped_logistic


def load_clustering_json(fn):
    f = open(fn)
    raw_clusters = json.load(f)
    f.close()
    documents = set()
    clusters = []
    for cluster in raw_clusters:
        cluster = frozenset(x['document'] for x in cluster)
        clusters.append(cluster)
        documents.update(cluster)

    return documents, clusters


def calc_fbcubed(truth, clusters):
    r = 0.0
    p = 0.0
    n = 0.0
    for cluster in clusters.values():
        n += len(cluster)
        for d in cluster:
            tcluster = truth[d]
            correct = len(cluster & tcluster)
            pp = float(correct) / len(cluster)
            rr = float(correct) / len(tcluster)
            p += pp
            r += rr
    rp = n / p
    rr = n / r
    return 2.0 / (rp + rr)


def symmetricise(x):
    return (x + x.T) * 0.5


def norm2(x):
    return x - np.diagonal(x)

LINE_WIDTH = 0.5

STRATEGIES = {
    'raw_asymmetric': (False, (neg,)),
    'raw': (False, (neg, symmetricise)),
    'simple': (True, (neg, symmetricise)),
    'norm2': (True, (neg, norm2)),
    'norm2-symmetric': (True, (neg, norm2, symmetricise)),
    'asymmetric': (True, (neg,)),
    'best_connections': (True, (neg, symmetricise, best_connections)),
    'montecarlo': (True, (symmetricise, clipped_neg_exp, p_to_affinities)),
    'montecarlo-norm2': (True, (norm2, symmetricise, clipped_neg_exp,
                                p_to_affinities)),
    'montecarlo-asymmetric': (True, (clipped_neg_exp, p_to_affinities)),
    'montecarlo-raw': (False, (clipped_neg_exp, p_to_affinities)),
    'montecarlo-sigmoid-raw': (False, (clipped_logistic, p_to_affinities)),
    'montecarlo-sigmoid': (True, (symmetricise, clipped_logistic,
                                  p_to_affinities)),
    'montecarlo-sigmoid-norm2': (True, (symmetricise, norm2, clipped_logistic,
                                        p_to_affinities)),
    'sigmoid': (True, (symmetricise, clipped_logistic,)),
    'sigmoid-asymmetric': (True, (clipped_logistic,)),
    'sigmoid-raw': (False, (clipped_logistic,)),
}


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-i', '--input',
                        help='input filename (pickle)')

    parser.add_argument('-g', '--ground-truth-dir',
                        help='cluster ground truth (json)')

    parser.add_argument('--strategy', default='simple',
                        help='how to process the affinities (%s)' %
                        (', '.join(STRATEGIES.keys())))

    parser.add_argument('--n-clusters', action='store_true',
                        help='plot the number of clusters at each threshold')

    parser.add_argument('--n-links', action='store_true',
                        help='plot the number of links at each threshold')

    parser.add_argument('--delta', action='store_true',
                        help='changes in threshold')

    parser.add_argument('--time', action='store_true',
                        help=('show no figure, print elapsed '
                              'time for first problem'))

    args = parser.parse_args()

    f = open(args.input)
    data = cPickle.load(f)
    f.close()
    affinities, names, control_means = data

    if args.time:
        start_time = time.time()

    if args.ground_truth_dir:
        true_clusters = {}
        for pid in affinities:
            fn = os.path.join(args.ground_truth_dir, pid, 'clustering.json')
            documents, clusters = load_clustering_json(fn)
            for cluster in clusters:
                for doc in cluster:
                    true_clusters[doc] = cluster
    else:
        true_clusters = None

    for tag, data in affinities.items():
        print tag
        control, functions = STRATEGIES[args.strategy]
        if control:
            data -= control_means[tag]
        for func in functions:
            data = func(data)

        thresholds = np.unique(data)

        fig = plt.figure(figsize=(12, 10))
        ax = fig.add_subplot(111)
        ax.set_title(tag)
        ax.plot(thresholds, 'r.', linewidth=LINE_WIDTH, label='thresholds')

        if args.delta:
            deltas = np.diff(thresholds) * 10
            ax.plot(deltas, 'c.', linewidth=LINE_WIDTH, label='delta')

        if args.n_clusters:
            n_clusters = []
            prev_n = -1e99
            prev_t = -1e99
            for t in thresholds:
                clusters = data_to_clusters(data, t)
                n = len(clusters)
                n_clusters.append(n / float(data.shape[0]))
                if n < prev_n:
                    print "prev     %d, threshold %s" % (prev_n, prev_t)
                    print "clusters %d, threshold %s" % (n, t)
                prev_n = n
                prev_t = t

            ax.plot(n_clusters, 'g.', linewidth=LINE_WIDTH, label='n clusters')


        if args.n_links:
            n_links = []
            w = data.shape[0]
            scale = 1.0 / (w * w)
            prev_links = 1e99
            prev_t = -1e99
            for t in thresholds:
                links = np.sum(data > t)
                if links > prev_links:
                    print "prev links %d, threshold %s" % (prev_links, prev_t)
                    print "     links %d, threshold %s" % (links, t)
                prev_links = links
                prev_t = t
                n_links.append(links * scale)
            ax.plot(n_links, 'y.', linewidth=LINE_WIDTH, label='n links')

        if true_clusters is not None:
            fbcubed = []
            old_clusters = None
            score = None
            for t in thresholds:
                clusters = data_to_clusters(data, t, names[tag])
                if clusters != old_clusters:
                    score = calc_fbcubed(true_clusters, clusters)
                    old_clusters = clusters
                fbcubed.append(score)
            ax.plot(fbcubed, 'b.', linewidth=LINE_WIDTH, label='fbcubed')

        plt.legend(loc='center left', numpoints=1, frameon=False,
                   borderpad=0)

        if args.time:
            elapsed = time.time() - start_time
            print "%s %s took %.2f seconds" % (tag, data.shape, elapsed)
            sys.exit()
        plt.show()

main()
